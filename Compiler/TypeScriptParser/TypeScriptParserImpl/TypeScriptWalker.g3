tree grammar TypeScriptWalker;

options
{
	ASTLabelType = CommonTree;
	tokenVocab = TypeScript;
	k = 4;
}

@namespace { TypeScriptParser.TypeScriptParserImpl }

@header {
using System;
using TypeScriptModel.Model;
#pragma warning disable 219, 162, 3021
}

@members {
	public override void ReportError(RecognitionException e) { ErrorReporter.ReportError(e.Line, e.CharPositionInLine, "Internal error: " + GetErrorMessage(e, TokenNames)); }
	public IErrorReporter ErrorReporter { get; set; }
}

public program returns [Globals result]
	@init { var members = new List<Member>(); var modules = new List<Module>(); var interfaces = new List<Interface>(); }
	: ( ^(DECLARE v=variableDeclaration { members.Add(v); })
	  | ^(DECLARE i=interfaceDeclaration { interfaces.Add(i); })
	  | d=moduleDeclaration { modules.Add(d); }
	  )*
	  EOF
	{ $result = new Globals(modules, interfaces, members); }
	;

variableDeclaration returns [Member result]
	: (x=Identifier t=type? { $result = new Variable(x.Text, t, false); })
	| (x=Identifier l=parameterList t=type? { $result = new Function(x.Text, t, l); })
	;

interfaceDeclaration returns [Interface result]
	: ^(INTERFACE i=Identifier e=extendsDeclaration? t=compositeType) { $result = new Interface(i.Text, e ?? new List<TypeReference>(), t.Members); }
	;

extendsDeclaration returns [List<TypeReference> result]
	@init { $result = new List<TypeReference>(); }
	: ^(EXTENDS (t=typeReference { $result.Add(t); })+)
	;

moduleDeclaration returns [Module result]
	@init { var imports = new List<ModuleImport>(); var exportedMembers = new List<Member>(); var members = new List<Member>(); var exportedInterfaces = new List<Interface>(); var interfaces = new List<Interface>(); bool export = false; }
	: ^(MODULE n=Identifier (  p=importDeclaration { imports.Add(p); }
	                         | ^((DECLARE { export = false; } | EXPORT { export = true; }) (  (i=interfaceDeclaration { (export ? exportedInterfaces : interfaces).Add(i); })
	                                                                                        | (v=variableDeclaration { (export ? exportedMembers : members).Add(v); })
	                                                                                       ))
	                        )*
	  )
	{ $result = new Module(n.Text, imports, exportedMembers, members, exportedInterfaces, interfaces); }
	;

importDeclaration returns [ModuleImport result]
	: ^(IMPORT a=Identifier m=Identifier) { $result = new ModuleImport(m.Text, a.Text); }
	;

type returns [TSType result]
	: tr=typeReference { $result = tr; }
	| ct=compositeType { $result = ct; }
	| at=arrayType { $result = at; }
	| ft=functionType { $result = ft; }
	;

typeReference returns [TypeReference result]
	: Identifier { $result = new TypeReference($Identifier.Text); }
	;

compositeType returns [CompositeType result]
	@init { var members = new List<Member>(); }
	: ^(COMPOSITE_TYPE (m=member { members.Add(m); })*)
	{ $result = new CompositeType(members); }
	;

arrayType returns [ArrayType result]
	: ^(ARRAY_TYPE t=type) { $result = new ArrayType(t); }
	;

functionType returns [FunctionType result]
	: ^(FUNCTION_TYPE l=parameterList t=type?) { $result = new FunctionType(l, t); }
	;

member returns [Member result]
	: ^(VAR Identifier t=type?) { $result = new Variable($Identifier.Text, t, false); }
	| ^(VAR_OPT Identifier t=type?) { $result = new Variable($Identifier.Text, t, true); }
	| ^(FUNCTION i=Identifier? l=parameterList t=type?) { $result = new Function(i != null ? i.Text : null, t, l); }
	| ^(CONSTRUCTOR l=parameterList t=type?) { $result = new Constructor(t, l); }
	| ^(INDEX p=parameter t=type?) { $result = new Indexer(t, p.Name, p.Type); }
	;

parameterList returns [List<Parameter> result]
	@init { $result = new List<Parameter>(); }
	: ^(PARAMS (p=parameter { $result.Add(p); })* )
	;

parameter returns [Parameter result]
	@init { bool optional = false, paramArray = false; }
	: ^((PARAM | PARAM_OPT { optional = true; } | PARAM_ARRAY { paramArray = true; }) i=Identifier t=type? { $result = new Parameter(i.Text, t, optional, paramArray); })
	;
